/* TODO: //////////////////////////////////////////
-- create a common parent for warning and error first
-- switch statement (jump table impl)
-- refactor throw error to function from macros
-- undef THROW_ANLAYZER_ERROR, TOKENIZER_ERROR, ... (not THROW_BUG)
-- error print and dbg info (stack trace)
-- opcode string print
-- "string %s literal"_s % {"replace"}
-- ext_lib.lib.lib;
-- change owner pointer from shared to weak

-- class A{} var a = A; println(a.get_type_name()); // RuntimeInstance
-- a rich typecheck api
-- "".substr() check index limit
-- float("") <-- crash
-- try super.EnumClass(); <-- check error msg

----- TODO ADDNL -----
-- i++, i--
-- reverse list, string, slice array
-- " ".join(arr), strip, trim... try dir("") in python and implement all.
-- python like range().
-- dir() function
-- in, is 

-- func f(x) = 2*x + 1; lambda
-- [expr(i) for i in expr]
-- a, b = b, a
-- map(f, arr) -> arr // can implement in carbon too.
-- implement __repr__() // print array of string / or add "" manually in arr/dict
-- trinary if else
-- return a, b, c // maybe


---- current features -----------------------------------
-- dynamic type (strongly typed) high level
-- object oriented (and functional c++ like)
-- operator overloading support
       - arighmetic operators
       - callables
	   - iterables
-- default argument support
-- first class function/classes/enums and everything
-- easy integration (c++ bindings)
-- no memeory management required
-- a better analyzer (to reduce runtime errors)
-- basic language features:
	   - enums and switch statements
	   - for, foreach, while loops, if, else
	   - static and non static variables/ functions.

-- get_func()(); vars_callable();
-- func f(x) = x + 2; // single expr function defn
-- support both `&&`/`and` , `||`/`or`, `!`/`not`
-- python like arithmetic operators in builtin
        - "str" * 3, [3.14] * 10
		- "%s - %s" % "first", "second"; // <-- TODO:
//////////////////////////////////////////////////// */


//import lib = "test_lib.cb";
func main() {
}


// https://www.geeksforgeeks.org/count-number-of-subsets-of-a-set-with-gcd-equal-to-a-given-number/

func gcd_subset(gcd, nums) {
	var frequency = Map();
	var subsets = Map();
	var num_max = 0;

	for (var i = 0; i < nums.size(); i+=1) {
		frequency[num[i]] += 1;
		if (nums[i] > num_max) num_max = nums[i];
	}

	for (var i = num_max; i >= 1; i-=1) {
		var factor_count = frequency[i]; // these many numbers can divided by i
		var subtract_subsets = 0;

		for (var j = 2; i * j <= num_max; j+=1) {
			factor_count += frequency[i * j];
			subtract_subsets += subsets[i * j];
		}
		subsets[i] = (1 << factor_count) - 1 - subtract_subsets;
	}

	for (var i = 0; i < gcd.size(); i+=1) {
		print(subsets[gcd[i]]);
	}
}
